<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Database Change Management with Schemachange and GitHub</title>
      <link href="/Snowflake-DevOps/"/>
      <url>/Snowflake-DevOps/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1. Overview"></a>1. Overview</h1><p><img src="/Snowflake-DevOps/ov.png" alt><br>&emsp;&emsp;本指南将提供有关如何使用 GitHub Actions 为 Snowflake 构建简单的 CI/CD 管道的分步说明。我希望这将为您提供足够的详细信息，以便您开始使用 Snowflake 和 GitHub Actions 进行 DevOps 之旅。<br>&emsp;&emsp;DevOps 关注软件应用程序的自动化开发、发布和维护。因此，DevOps非常广泛，涵盖了整个软件开发生命周期(SDLC)。用于管理整个SDLC的软件工具环境很复杂，因为有许多不同的必需功能/工具，包括：</p><ul><li>需求管理</li><li>项目管理（瀑布式、敏捷/Scrum）</li><li>源代码管理（版本控制）</li><li>生成管理 （CI/CD）</li><li>测试管理 （CI/CD）</li><li>发布管理 （CI/CD）  </li></ul><p>&emsp;&emsp;本指南将主要重点介绍如何利用 GitHub 的 GitHub Actions 服务对 Snowflake 进行自动化发布管理。此外，为了在 Snowflake 中管理数据库对象/更改，将使用 schemachange 数据库更改管理 （DCM） 工具。</p><h2 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h2><p>&emsp;&emsp;本指南假定您具备 Git 存储库的基本工作知识。</p><h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ul><li>GitHub Actions 的简要历史和概述</li><li>架构更改的简要历史和概述</li><li>架构更改等数据库更改管理工具的工作原理</li><li>简单的发布管道的工作原理</li><li>如何在 GitHub Actions 中创建 CI/CD 管道</li><li>具有阶段的更高级 CI/CD 管道的想法</li><li>如何开始使用分支策略</li><li>如何开始使用测试策略</li></ul><h2 id="您需要的内容"><a href="#您需要的内容" class="headerlink" title="您需要的内容"></a>您需要的内容</h2><p>&emsp;&emsp;在开始之前，您将需要以下内容： </p><ul><li><a href="https://signup.snowflake.com/developers"><strong>Snowflake 帐户</strong></a></li><li><strong>名为 DEMO_DB 的 Snowflake 数据库</strong></li><li><a href="https://github.com/signup"><strong>Github 帐户</strong></a></li><li><strong>GitHub 存储库</strong></li><li><strong>GIT</strong></li><li><strong>集成开发环境 （IDE）</strong></li></ul><h2 id="构建内容"><a href="#构建内容" class="headerlink" title="构建内容"></a>构建内容</h2><p>&emsp;&emsp;GitHub Actions 中 Snowflake 的简单、有效的发布管道</p>]]></content>
      
      
      <categories>
          
          <category> Snowflake </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Snowflake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Snowflake 开发规范拟定 v1.0</title>
      <link href="/Snowflake-Dev-Specification/"/>
      <url>/Snowflake-Dev-Specification/</url>
      
        <content type="html"><![CDATA[<h1 id="Snowflake-数据仓库开发规范-v1-0"><a href="#Snowflake-数据仓库开发规范-v1-0" class="headerlink" title="Snowflake 数据仓库开发规范 v1.0"></a>Snowflake 数据仓库开发规范 v1.0</h1><div class="table-container"><table><thead><tr><th style="text-align:center">版本号</th><th style="text-align:center">修订日期</th><th style="text-align:center">修订人</th><th style="text-align:center">修订说明</th></tr></thead><tbody><tr><td style="text-align:center">v1.0</td><td style="text-align:center">2024-01-13</td><td style="text-align:center">LiuZhu</td><td style="text-align:center">初步拟定命名规范、分层规范、代码格式规范等</td></tr></tbody></table></div><h2 id="1-命名规范"><a href="#1-命名规范" class="headerlink" title="1. 命名规范"></a>1. 命名规范</h2><h3 id="1-1-数据库命名规范"><a href="#1-1-数据库命名规范" class="headerlink" title="1.1 数据库命名规范"></a>1.1 数据库命名规范</h3><ul><li>所有的数据库名称应 <strong>全部大写</strong>，使用下划线分隔词语。</li><li>避免使用保留关键字作为数据库名。</li></ul><p>例如：<code>RAW_DATA</code> </p><h3 id="1-2-表命名规范"><a href="#1-2-表命名规范" class="headerlink" title="1.2 表命名规范"></a>1.2 表命名规范</h3><ul><li>所有的表名 <strong>全部大写</strong>，使用下划线分隔词语。</li><li>表名应该清晰地反映表的内容。</li><li>避免使用保留关键字作为表名。</li></ul><p>例如：<code>CUSTOMER_DETAILS</code></p><h3 id="1-3-列命名规范"><a href="#1-3-列命名规范" class="headerlink" title="1.3 列命名规范"></a>1.3 列命名规范</h3><ul><li>所有的列名 <strong>全部大写</strong>，使用下划线分隔词语。</li><li>列名应该清晰地反映列的内容。</li><li>避免使用保留关键字作为列名。</li></ul><p>例如：<code>CUSTOMER_ID</code></p><h3 id="1-4-事实表命名规范"><a href="#1-4-事实表命名规范" class="headerlink" title="1.4 事实表命名规范"></a>1.4 事实表命名规范</h3><ul><li>事实表的名字应该以 <strong>FACT_</strong> 开头，后接表达该表内容的名词，使用大写字母并用下划线分隔词语。</li><li>事实表的名字应该清晰地反映表的内容。</li></ul><p>例如：<code>FACT_SALES</code></p><h3 id="1-5-维度表命名规范"><a href="#1-5-维度表命名规范" class="headerlink" title="1.5 维度表命名规范"></a>1.5 维度表命名规范</h3><ul><li>维度表的名字应该以 <strong>DIM_</strong> 开头，后接表达该表内容的名词，使用大写字母并用下划线分隔词语。</li><li>维度表的名字应该清晰地反映表的内容。</li></ul><p>例如：<code>DIM_CUSTOMER</code></p><h3 id="1-6-映射表命名规范"><a href="#1-6-映射表命名规范" class="headerlink" title="1.6 映射表命名规范"></a>1.6 映射表命名规范</h3><ul><li>映射表的名字应该以 <strong>MAP_</strong> 开头，后接表达该表内容的名词，使用大写字母并用下划线分隔词语。</li><li>映射表的名字应该清晰地反映表的内容。</li></ul><p>例如：<code>MAP_PRODUCT_CATEGORY</code></p><h3 id="1-7-函数命名规范"><a href="#1-7-函数命名规范" class="headerlink" title="1.7 函数命名规范"></a>1.7 函数命名规范</h3><ul><li>函数名应清晰地描述函数的功能。</li><li>函数名应以 <strong>F<em>动词</em></strong> 开始，以表明它们执行的操作。</li></ul><p>例如：<code>F_CALCULATE_TOTAL_REVENUE</code></p><h3 id="1-8-存储过程命名规范"><a href="#1-8-存储过程命名规范" class="headerlink" title="1.8 存储过程命名规范"></a>1.8 存储过程命名规范</h3><ul><li>存储过程名称应清楚地描述它们执行的操作。</li><li>存储过程名称应以 <strong>SP_</strong> 为前缀。</li></ul><p>例如：<code>SP_UPDATE_CUSTOMER_STATUS</code></p><h3 id="1-9-视图命名规范"><a href="#1-9-视图命名规范" class="headerlink" title="1.9 视图命名规范"></a>1.9 视图命名规范</h3><ul><li>视图名称应清楚地描述它们所显示的数据。</li><li>视图名称应以 <strong>V_</strong> 为前缀。</li></ul><p>例如：<code>V_SALES_SUMMARY</code></p><h2 id="2-数据仓库分层规范"><a href="#2-数据仓库分层规范" class="headerlink" title="2. 数据仓库分层规范"></a>2. 数据仓库分层规范</h2><h3 id="2-1-原始层-Raw-Layer"><a href="#2-1-原始层-Raw-Layer" class="headerlink" title="2.1 原始层 (Raw Layer)"></a>2.1 原始层 (Raw Layer)</h3><ul><li>这一层是数据仓库的入口，应该包含所有源系统的数据的完整复制品。</li><li>数据应该以最原始的形式存储，不进行任何转换或清洗。</li><li>数据库名：<code>RAW_DATA</code></li></ul><h3 id="2-2-清洗层-Clean-Layer"><a href="#2-2-清洗层-Clean-Layer" class="headerlink" title="2.2 清洗层 (Clean Layer)"></a>2.2 清洗层 (Clean Layer)</h3><ul><li>在这一层，数据应该进行清洗和转换，以满足业务需求。</li><li>清洗过程包括数据质量检查、缺失值处理、错误值处理等。</li><li>数据库名：<code>CLEAN_DATA</code></li></ul><h3 id="2-3-业务层-Business-Layer"><a href="#2-3-业务层-Business-Layer" class="headerlink" title="2.3 业务层 (Business Layer)"></a>2.3 业务层 (Business Layer)</h3><ul><li>在这一层，数据应该根据业务需求进行进一步的转换和聚合。</li><li>这一层的数据应该满足大部分报表和分析的需求。</li><li>数据库名：<code>BUSSINESS_DATA</code></li></ul><h3 id="2-4-展示层-Presentation-Layer"><a href="#2-4-展示层-Presentation-Layer" class="headerlink" title="2.4 展示层 (Presentation Layer)"></a>2.4 展示层 (Presentation Layer)</h3><ul><li>这一层的数据应该是为最终用户准备的，应该直接满足报表和分析的需求。</li><li>应该尽可能地简化这一层的数据结构，使其易于理解和使用。</li><li>数据库名：<code>REPORTING_DATA</code></li></ul><h2 id="3-代码格式规范"><a href="#3-代码格式规范" class="headerlink" title="3. 代码格式规范"></a>3. 代码格式规范</h2><p>以下是一些基本的SQL代码格式规范，适用于Snowflake：</p><h3 id="3-1-关键字"><a href="#3-1-关键字" class="headerlink" title="3.1 关键字"></a>3.1 关键字</h3><p>SQL关键字应全部大写，如<code>SELECT</code>、<code>FROM</code>、<code>WHERE</code>等。</p><h3 id="3-2-缩进"><a href="#3-2-缩进" class="headerlink" title="3.2 缩进"></a>3.2 缩进</h3><p>使用缩进来提高代码的可读性。例如，<code>FROM</code>、<code>WHERE</code>、<code>GROUP BY</code>等子句应当在新的一行开始，并且相对于<code>SELECT</code>关键字缩进。</p><h3 id="3-3-别名"><a href="#3-3-别名" class="headerlink" title="3.3 别名"></a>3.3 别名</h3><p>在查询中使用别名时，别名应清晰地描述列或表的内容。</p><h3 id="3-4-注释"><a href="#3-4-注释" class="headerlink" title="3.4 注释"></a>3.4 注释</h3><p>应使用注释来解释代码的功能和目的。注释应以<code>--</code>开始，放在需要解释的代码行的上一行。</p><h3 id="3-5-空格"><a href="#3-5-空格" class="headerlink" title="3.5 空格"></a>3.5 空格</h3><p>在操作符两侧使用空格，如<code>=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>。</p><h2 id="4-其他规范"><a href="#4-其他规范" class="headerlink" title="4. 其他规范"></a>4. 其他规范</h2><ul><li>应该定期备份数据，以防数据丢失。</li><li>应该定期检查数据质量，以确保数据的准确性。</li><li>在开发过程中，应该遵循最佳实践，包括使用版本控制、编写可读的代码、进行单元测试等。</li></ul><p>以上规范只是一个基本的指南，实际的开发规范应该根据具体的项目需求和团队习惯进行调整。</p>]]></content>
      
      
      <categories>
          
          <category> Snowflake </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Snowflake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zero to Snowflake</title>
      <link href="/Zero-to-Snowflake/"/>
      <url>/Zero-to-Snowflake/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>&emsp;&emsp;欢迎来到Snowflake！这本入门级指南专为数据库和数据仓库管理员和架构师设计，将帮助您浏览 Snowflake 界面，并向您介绍我们的一些核心功能。注册 Snowflake 的 30 天免费试用版，并按照此实验练习进行操作。一旦我们介绍了基础知识，您就可以开始处理自己的数据，并像专业人士一样深入研究 Snowflake 的更高级功能。</p><h2 id="先决条件："><a href="#先决条件：" class="headerlink" title="先决条件："></a>先决条件：</h2><ul><li>使用 Snowflake 30 天免费试用环境</li><li>熟悉SQL、数据库概念和对象的基本知识</li><li>熟悉 CSV 逗号分隔文件和 JSON 半结构化数据</li></ul><h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ul><li>如何创建schema、database、table、view和Virtual Warehouse。</li><li>如何加载结构化和半结构化数据。</li><li>如何对Snowflake中的数据执行分析查询，包括表之间的联接。</li><li>如何克隆对象。</li><li>如何使用Time Travel撤销错误。</li><li>如何创建角色和用户，并授予他们权限。</li><li>如何安全轻松地与其他帐户共享数据。</li><li>如何在 Snowflake Data Marketplace 中使用数据集。</li></ul><h1 id="准备实验环境"><a href="#准备实验环境" class="headerlink" title="准备实验环境"></a>准备实验环境</h1><p>&emsp;&emsp;如果您尚未注册，请<a href="https://signup.snowflake.com/developers"><strong>注册 Snowflake 30 天免费试用版</strong></a>。本实验的其余部分假定您使用的是通过注册试用版创建的新 Snowflake 帐户。<br>&emsp;&emsp;用于此实验的 Snowflake 版本（标准版、企业版、关键业务版等）和云提供商（AWS、Azure、GCP）和区域（美国东部、欧盟等）无关紧要。但是，我们建议您选择离您最近的区域，以及我们最受欢迎的产品 Enterprise（我们最受欢迎的产品）作为您的 Snowflake 版本。<br>注册后，您将收到一封电子邮件，其中包含用于访问您的 Snowflake 帐户的激活链接和 URL。</p><h1 id="Snowflake用户界面和Lab-Story"><a href="#Snowflake用户界面和Lab-Story" class="headerlink" title="Snowflake用户界面和Lab Story"></a>Snowflake用户界面和Lab Story</h1><blockquote><p>关于屏幕截图、示例代码和环境本实验中的屏幕截图描述的示例和结果可能与完成练习时看到的略有不同。</p></blockquote><h2 id="登录-Snowflake-用户界面-（UI）"><a href="#登录-Snowflake-用户界面-（UI）" class="headerlink" title="登录 Snowflake 用户界面 （UI）"></a>登录 Snowflake 用户界面 （UI）</h2><p>&emsp;&emsp;打开浏览器窗口，然后输入随注册电子邮件一起发送的 Snowflake 30 天试用环境的 URL。<br>&emsp;&emsp;您应该会看到以下登录对话框。输入您在注册时指定的用户名和密码：<br><img src="/Zero-to-Snowflake/signin.png" alt></p><h2 id="导航-Snowflake-UI"><a href="#导航-Snowflake-UI" class="headerlink" title="导航 Snowflake UI"></a>导航 Snowflake UI</h2><p>&emsp;&emsp;让我们来熟悉一下Snowflake吧！本节介绍用户界面的基本组件</p><h3 id="Worksheets"><a href="#Worksheets" class="headerlink" title="Worksheets"></a>Worksheets</h3><p><img src="/Zero-to-Snowflake/worksheets.png" alt><br>&emsp;&emsp;<strong>工作表</strong>选项卡提供了一个界面，用于提交 SQL 查询、执行 DDL 和 DML 操作，以及在查询或操作完成时查看结果。单击右上角的 <strong>+</strong> 即可创建一个新工作表。<br><img src="/Zero-to-Snowflake/query.png" alt></p><h3 id="Dashboard"><a href="#Dashboard" class="headerlink" title="Dashboard"></a>Dashboard</h3><p><img src="/Zero-to-Snowflake/Dashboard.png" alt><br>&emsp;&emsp;<strong>仪表板</strong>选项卡允许您创建一个或多个图表的灵活显示（以磁贴的形式，可以重新排列）。磁贴和小组件是通过执行在工作表中返回结果的 <strong>SQL查询</strong>来生成的。<br><img src="/Zero-to-Snowflake/dashboard2.png" alt><br>&emsp;&emsp;可以看到，通过仪表盘，我们可以快速地执行出预先写好的SQL语句，并以磁贴的形式展示出来。</p><h3 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h3><h4 id="Database"><a href="#Database" class="headerlink" title="Database"></a>Database</h4><p><img src="/Zero-to-Snowflake/database.png" alt><br>&emsp;&emsp;在<strong>数据</strong>下，<strong>数据库</strong>选项卡显示有关已创建或有权访问的数据库的信息。您可以创建、克隆、删除或转移数据库的所有权，以及在 UI 中加载数据。单击右上角的 <strong>+</strong> 即可创建一个新数据库。</p><h4 id="Private-Sharing"><a href="#Private-Sharing" class="headerlink" title="Private Sharing"></a>Private Sharing</h4><p><img src="/Zero-to-Snowflake/ps.png" alt><br>&emsp;&emsp;此外，在<strong>数据</strong>下，<strong>私有共享数据</strong>选项卡可以配置数据共享，以便在单独的 Snowflake 帐户或外部用户之间轻松安全地共享 Snowflake 表，而无需创建数据副本。我们将在第 10 节中介绍数据共享。</p><h3 id="Marketplace"><a href="#Marketplace" class="headerlink" title="Marketplace"></a>Marketplace</h3><p><img src="/Zero-to-Snowflake/market.png" alt><br>&emsp;&emsp;在<strong>市场</strong>选项卡中，任何 Snowflake 客户都可以浏览和使用提供商提供的数据集。共享数据有两种类型：公共数据和个性化数据。公共数据是可用于即时查询的免费数据集。个性化数据需要联系数据提供商以批准共享数据。</p><h3 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h3><h4 id="Query-History-amp-Copy-History"><a href="#Query-History-amp-Copy-History" class="headerlink" title="Query History &amp; Copy History"></a>Query History &amp; Copy History</h4><p><img src="/Zero-to-Snowflake/qh.png" alt> <img src="/Zero-to-Snowflake/ch.png" alt><br>&emsp;&emsp;在<strong>活动</strong>下，有两个选项卡：<strong>查询历史记录</strong>和<strong>复制历史记录</strong>：</p><ul><li><strong>查询历史记录</strong>是显示以前查询的位置，以及可用于优化结果（用户、仓库、状态、查询标记等）的筛选器。查看过去 14 天内从您的 Snowflake 账户执行的所有查询的详细信息。单击查询 ID 以获取更多信息。</li><li><strong>复制历史记录</strong>显示为将数据提取到 Snowflake 而运行的<strong>复制命令</strong>的状态。</li></ul><h3 id="Admin"><a href="#Admin" class="headerlink" title="Admin"></a>Admin</h3><h4 id="Cost-Management"><a href="#Cost-Management" class="headerlink" title="Cost Management"></a>Cost Management</h4><p><img src="/Zero-to-Snowflake/cm.png" alt><br>&emsp;&emsp;在<strong>管理员</strong>下，<strong>成本管理</strong>选项卡显示出费用的使用情况，供管理员了解成本和性价比指标。通过设置预算和资源监视器来控制支出，并发现用于优化 Snowflake 消耗的开箱即用见解。</p><h4 id="Warehouses"><a href="#Warehouses" class="headerlink" title="Warehouses"></a>Warehouses</h4><p><img src="/Zero-to-Snowflake/wh.png" alt><br>&emsp;&emsp;在<strong>管理员</strong>下，<strong>仓库</strong>选项卡可用于设置和管理称为虚拟仓库的<strong>计算资源</strong>，以在 Snowflake 中加载或查询数据。您的环境中已存在一个名为 <code>COMPUTE_WH</code> 的仓库。</p><h4 id="Users-amp-Roles"><a href="#Users-amp-Roles" class="headerlink" title="Users &amp; Roles"></a>Users &amp; Roles</h4><p><img src="/Zero-to-Snowflake/users.png" alt><br>&emsp;&emsp;在<strong>管理员</strong>下，<strong>用户和角色</strong>选项卡的<strong>用户</strong>子选项卡显示帐户中的用户列表、默认角色和用户所有者。对于新帐户，不会显示任何记录，因为尚未创建其他角色。通过当前角色授予的权限决定了此选项卡显示的信息。若要查看选项卡上提供的所有信息，请将您的角色切换为 <code>ACCOUNTADMIN</code>。<br> <img src="/Zero-to-Snowflake/roles.png" alt><br>&emsp;&emsp;在<strong>管理员</strong>下，<strong>用户和角色</strong>选项卡的<strong>角色</strong>子选项卡显示角色及其层次结构的列表。可以在此选项卡中创建、重新组织角色并将其授予用户。还可以通过选择<strong>表</strong>子选项卡以表格/列表格式显示角色。</p><h2 id="实验室故事"><a href="#实验室故事" class="headerlink" title="实验室故事"></a>实验室故事</h2><p>&emsp;&emsp;该实验室基于花旗自行车的分析团队，花旗自行车是美国纽约市一个真正的全市自行车共享系统。该团队希望对来自其内部交易系统的数据进行分析，以更好地了解他们的乘客以及如何最好地为他们服务。<br>&emsp;&emsp;我们将首先将来自骑手交易的结构化数据加载到 Snowflake 中。稍后，我们将使用开源的半结构化 JSON 天气数据来确定骑自行车的次数与天气之间是否存在任何相关性。<code>.csv</code></p><h1 id="准备加载数据"><a href="#准备加载数据" class="headerlink" title="准备加载数据"></a>准备加载数据</h1><p>&emsp;&emsp;首先，我们准备将结构化的 Citi Bike 骑手交易数据加载到 Snowflake 中。<br>&emsp;&emsp;本部分将指导您完成以下步骤：</p><ul><li>创建数据库和表。</li><li>创建外部存储区。</li><li>为数据创建文件格式。</li></ul><blockquote><p>将数据导入 Snowflake可通过多种方式将数据从多个位置导入 Snowflake，包括 COPY 命令、Snowpipe 自动摄取、外部连接器或第三方 ETL/ELT 解决方案。有关将数据导入 Snowflake 的更多信息，请参阅 Snowflake 文档。在本实验中，我们使用 COPY 命令和 AWS S3 存储来手动加载数据。在实际场景中，您更有可能使用自动化流程或 ETL 解决方案。</p></blockquote><p>&emsp;&emsp;我们将使用的数据是由Citi Bike NYC提供的自行车共享数据。数据已导出并预暂存到美国东部区域的 Amazon AWS S3 存储桶中。数据包括有关旅行时间、位置、用户类型、性别、年龄等的信息。在 AWS S3 上，数据表示 61.5M 行、377 个对象和 1.9GB 压缩。<br>&emsp;&emsp;以下是 Citi Bike CSV 数据文件之一的片段：<br><img src="/Zero-to-Snowflake/cbc.png" alt>  &emsp;&emsp;它采用逗号分隔的格式，使用单个标题行和双引号括起所有字符串值，包括标题行中的字段标题。这将在本节后面的配置中发挥作用，因为我们配置 Snowflake 表来存储此数据。</p><h2 id="创建数据库和表"><a href="#创建数据库和表" class="headerlink" title="创建数据库和表"></a>创建数据库和表</h2><p>&emsp;&emsp;首先，让我们创建一个用于加载结构化数据的数据库。<code>CITIBIKE</code><br>&emsp;&emsp;通过选择左上角的<strong>切换角色 &gt; SYSADMIN</strong>，确保使用 <code>SYSADMIN</code> 角色。<br>&emsp;&emsp;导航到<strong>数据库</strong>选项卡。单击<strong>创建</strong>，为数据库命名，然后单击“创建”。<code>CITIBIKE</code>  </p><p><img src="/Zero-to-Snowflake/createdb.png" alt></p><p>&emsp;&emsp;创建一个<strong>Worksheet</strong>，执行如下SQL语句，将<strong>角色</strong>和<strong>Warehouse</strong>切换成<code>SYSADMIN</code> 和 <code>COMPUTE_WH</code><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--切换到 ACCOUNTADMIN 角色</span></span><br><span class="line">USE ROLE ACCOUNTADMIN;</span><br><span class="line"><span class="comment">--将 COMPUTE_WH 权限授权给 SYSADMIN</span></span><br><span class="line"><span class="keyword">GRANT</span> OPERATE <span class="keyword">ON</span> WAREHOUSE COMPUTE_WH <span class="keyword">TO</span> ROLE SYSADMIN;</span><br><span class="line"><span class="keyword">GRANT</span> USAGE  <span class="keyword">ON</span> WAREHOUSE COMPUTE_WH <span class="keyword">TO</span> ROLE SYSADMIN;</span><br><span class="line"><span class="comment">--将管理warehouse权限授权给SYSADMIN</span></span><br><span class="line"><span class="keyword">GRANT</span> MANAGE WAREHOUSES <span class="keyword">ON</span> ACCOUNT <span class="keyword">TO</span> ROLE SYSADMIN;</span><br><span class="line"><span class="comment">--切换到 SYSADMIN 角色              </span></span><br><span class="line">USE ROLE SYSADMIN;             </span><br></pre></td></tr></table></figure><br><img src="/Zero-to-Snowflake/grant.png" alt></p><p>&emsp;&emsp;将Databases和Schemas选成刚刚创建好的<code>CITIBIKE``PUBLIC</code></p><p><img src="/Zero-to-Snowflake/ds.png" alt></p><p>&emsp;&emsp;接下来，我们创建一个用于加载逗号分隔数据的表。我们不使用 UI，而是使用工作表来运行创建表的 DDL。将以下 SQL 文本复制到工作表中：<code>TRIPS</code><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--创建表trips</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">table</span> trips</span><br><span class="line">(</span><br><span class="line"> tripduration            <span class="type">integer</span>,</span><br><span class="line"> starttime               <span class="type">timestamp</span>,</span><br><span class="line"> stoptime                <span class="type">timestamp</span>,</span><br><span class="line"> start_station_id        <span class="type">integer</span>,</span><br><span class="line"> start_station_name      string,</span><br><span class="line"> start_station_latitude  <span class="type">float</span>,</span><br><span class="line"> start_station_longitude <span class="type">float</span>,</span><br><span class="line"> end_station_id          <span class="type">integer</span>,</span><br><span class="line"> end_station_name        string,</span><br><span class="line"> end_station_latitude    <span class="type">float</span>,</span><br><span class="line"> end_station_longitude   <span class="type">float</span>,</span><br><span class="line"> bikeid                  <span class="type">integer</span>,</span><br><span class="line"> membership_type         string,</span><br><span class="line"> usertype                string,</span><br><span class="line"> birth_year              <span class="type">integer</span>,</span><br><span class="line"> gender                  <span class="type">integer</span></span><br><span class="line">);           </span><br></pre></td></tr></table></figure></p><p><img src="/Zero-to-Snowflake/trips.png" alt></p><blockquote><p>SQL 命令可以通过 UI、工作表选项卡、使用 SnowSQL 命令行工具、通过 ODBC/JDBC 选择的 SQL 编辑器或通过我们的其他连接器（Python、Spark 等）执行。如前所述，为了节省时间，我们通过工作表中执行的预先编写的 SQL 来执行本实验中的大部分操作，而不是使用 UI。</p></blockquote><p>&emsp;&emsp;创建完成后，可以通过点击左侧<code>Refresh</code>，即可查看到新创建的表 <code>CITIBIKE</code>&gt;<code>PUBLIC</code>&gt;<code>Tables</code>&gt;<code>TRIPS</code></p><p><img src="/Zero-to-Snowflake/602bfafc.png" alt></p><h2 id="创建外部Stage"><a href="#创建外部Stage" class="headerlink" title="创建外部Stage"></a>创建外部Stage</h2><p>&emsp;&emsp;我们正在处理结构化的逗号分隔数据，这些数据已暂存于公有的外部 <code>S3 存储桶</code>中。在使用此数据之前，我们首先需要创建一个 <code>Stage</code> 来指定外部存储桶的位置。</p><blockquote><p>在本实验中，我们使用的是 AWS-East 存储桶。为防止将来产生数据传出/传输成本，您应从与您的 Snowflake 帐户相同的云提供商和区域中选择暂存位置。</p></blockquote><p>&emsp;&emsp;在<strong>数据库</strong>选项卡中，单击<strong>CITIBIKE</strong>和<strong>PUBLIC</strong>。单击 <strong>Create （创建）</strong> 按钮，然后单击 <strong>Stage &gt; Amazon S3</strong>。</p><p><img src="/Zero-to-Snowflake/stage.png" alt></p><p>&emsp;&emsp;在弹出来的页面中填入<code>citibike_trips</code> 和 <code>s3://snowflake-workshop-lab/citibike-trips-csv/</code></p><p><img src="/Zero-to-Snowflake/createstage.png" alt></p><p>&emsp;&emsp;也可以在工作表中执行SQL<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> stage citibike_trips </span><br><span class="line">url <span class="operator">=</span> <span class="string">&#x27;s3://snowflake-workshop-lab/citibike-trips-csv/&#x27;</span>;</span><br><span class="line"><span class="comment">--credentials = (aws_secret_key = &#x27;&lt;key&gt;&#x27; aws_key_id = &#x27;&lt;id&gt;&#x27;)</span></span><br></pre></td></tr></table></figure></p><blockquote><p>此练习的 S3 存储桶是公有的，因此您可以将语句中的凭证选项留空。在实际场景中，用于外部阶段的存储桶可能需要关键信息。</p></blockquote><p>&emsp;&emsp;在工作表中执行如下SQL，在底部窗格中的结果中，应看到阶段中的文件列表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list <span class="variable">@citibike_trips</span>;</span><br></pre></td></tr></table></figure><p><img src="/Zero-to-Snowflake/trip_list.png" alt></p><h2 id="创建file-format"><a href="#创建file-format" class="headerlink" title="创建file format"></a>创建file format</h2><blockquote><p>在将数据加载到 Snowflake 中之前，我们必须创建与数据结构匹配的文件格式。</p></blockquote><p>&emsp;&emsp;在工作表中，执行下方SQL来创建文件file format</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--create file format</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace file format csv type<span class="operator">=</span><span class="string">&#x27;csv&#x27;</span></span><br><span class="line">  compression <span class="operator">=</span> <span class="string">&#x27;auto&#x27;</span> field_delimiter <span class="operator">=</span> <span class="string">&#x27;,&#x27;</span> record_delimiter <span class="operator">=</span> <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">  skip_header <span class="operator">=</span> <span class="number">0</span> field_optionally_enclosed_by <span class="operator">=</span> <span class="string">&#x27;\042&#x27;</span> trim_space <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">  error_on_column_count_mismatch <span class="operator">=</span> <span class="literal">false</span> <span class="keyword">escape</span> <span class="operator">=</span> <span class="string">&#x27;none&#x27;</span> escape_unenclosed_field <span class="operator">=</span> <span class="string">&#x27;\134&#x27;</span></span><br><span class="line">  date_format <span class="operator">=</span> <span class="string">&#x27;auto&#x27;</span> timestamp_format <span class="operator">=</span> <span class="string">&#x27;auto&#x27;</span> null_if <span class="operator">=</span> (<span class="string">&#x27;&#x27;</span>) comment <span class="operator">=</span> <span class="string">&#x27;file format for ingesting data for zero to snowflake&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="/Zero-to-Snowflake/c_file_format.png" alt></p><p>&emsp;&emsp;通过执行以下命令，验证是否已使用正确的设置创建文件格式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--verify file format is created</span></span><br><span class="line"><span class="keyword">show</span> file formats <span class="keyword">in</span> database citibike;</span><br></pre></td></tr></table></figure><p><img src="/Zero-to-Snowflake/show_file_formats.png" alt></p><h1 id="加载数据"><a href="#加载数据" class="headerlink" title="加载数据"></a>加载数据</h1><p>&emsp;&emsp;现在，我们可以运行 COPY 命令将数据加载到我们之前创建的表中。<code>TRIPS</code></p><p>&emsp;&emsp;在工作表中执行以下语句，将暂存数据加载到表中。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use warehouse COMPUTE_WH;</span><br><span class="line"><span class="keyword">copy</span> <span class="keyword">into</span> trips <span class="keyword">from</span> <span class="variable">@citibike_trips</span> file_format<span class="operator">=</span>csv <span class="keyword">PATTERN</span> <span class="operator">=</span> <span class="string">&#x27;.*csv.*&#x27;</span> ;</span><br></pre></td></tr></table></figure><p><img src="/Zero-to-Snowflake/33c9968e.png" alt></p><p>&emsp;&emsp;在结果窗格中，应看到已加载的每个文件的状态。加载完成后，在右下角的“查询详细信息”窗格中，可以滚动浏览最后执行的语句的各种状态、错误统计信息和可视化效果：</p><p>&emsp;&emsp;可以在<strong>Query Hisory</strong>中查看查询执行的步骤、查询详细信息、最昂贵的节点和其他统计信息。</p><p><img src="/Zero-to-Snowflake/query_history.png" alt></p><p>&emsp;&emsp;现在，让我们使用更大的仓库重新加载表，以查看额外的计算资源对加载时间的影响。<code>TRIPS</code></p><p>&emsp;&emsp;返回到工作表，并使用 TRUNCATE TABLE 命令清除表中的所有数据和元数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> trips;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过运行以下命令验证表是否为空：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--verify table is clear</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> trips limit <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><img src="/Zero-to-Snowflake/truncate_tb.png" alt></p><p>&emsp;&emsp;将仓库大小更改为使用以下 ALTER WAREHOUSE：<code>large</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--change warehouse size from small to large (4x)</span></span><br><span class="line"><span class="keyword">alter</span> warehouse compute_wh <span class="keyword">set</span> warehouse_size<span class="operator">=</span><span class="string">&#x27;large&#x27;</span>;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;使用以下 SHOW WAREHOUSES 验证更改：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--load data with large warehouse</span></span><br><span class="line"><span class="keyword">show</span> warehouses;</span><br></pre></td></tr></table></figure><p><img src="/Zero-to-Snowflake/show_wh.png" alt></p><p>&emsp;&emsp;执行与之前相同的 COPY INTO 语句以再次加载相同的数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">copy</span> <span class="keyword">into</span> trips <span class="keyword">from</span> <span class="variable">@citibike_trips</span></span><br><span class="line">file_format<span class="operator">=</span>CSV;</span><br></pre></td></tr></table></figure><p><img src="/Zero-to-Snowflake/copy_into.png" alt></p><p>&emsp;&emsp;比较两个 COPY INTO 命令的时间。使用<code>Large</code>的速度明显更快。</p><p><img src="/Zero-to-Snowflake/qh.png" alt></p><h2 id="为数据分析创建新仓库ANALYTICS-WH"><a href="#为数据分析创建新仓库ANALYTICS-WH" class="headerlink" title="为数据分析创建新仓库ANALYTICS_WH"></a>为数据分析创建新仓库<code>ANALYTICS_WH</code></h2><p>&emsp;&emsp;导航到<strong>Admin&gt;Warehouses</strong>选项卡，单击右上角<strong>＋ Warehouse</strong>，然后将新仓库命名为<code>ANALYTICS_WH</code>，并将大小设置为<code>Large</code>，启用<code>多集群仓库</code>，点击<strong>创建仓库</strong></p><p><img src="/Zero-to-Snowflake/new_wh.png" alt></p><h1 id="使用-Queries-Results-Cache-amp-Cloning"><a href="#使用-Queries-Results-Cache-amp-Cloning" class="headerlink" title="使用 Queries, Results Cache, &amp; Cloning"></a>使用 Queries, Results Cache, &amp; Cloning</h1><p>&emsp;&emsp;在前面的练习中，我们使用 Snowflake 的 COPY 批量加载程序命令和虚拟仓库将数据加载到两个表中。现在，我们将扮演Citi Bike的分析用户的角色，他们需要使用工作表和第二个仓库查询这些表中的数据。<code>COMPUTE_WH``ANALYTICS_WH</code></p><blockquote><p>在实际公司中，分析用户的角色可能与 SYSADMIN 不同。为了简化实验，我们将在本部分中保留 SYSADMIN 角色。此外，查询通常使用 Tableau、Looker、PowerBI 等商业智能产品完成。对于更高级的分析，Datarobot、Dataiku、AWS Sagemaker 等数据科学工具可以查询 Snowflake。任何利用 JDBC/ODBC、Spark、Python 或任何其他受支持的编程接口的技术都可以对 Snowflake 中的数据运行分析。为了简化此实验，所有查询都通过 Snowflake 工作表执行。</p></blockquote><h2 id="执行一些查询"><a href="#执行一些查询" class="headerlink" title="执行一些查询"></a>执行一些查询</h2><p>&emsp;&emsp;回到工作表，更改仓库以使用您在刚刚创建的新仓库<code>ANALYTICS_WH</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use warehouse analytics_wh;</span><br></pre></td></tr></table></figure><p><img src="/Zero-to-Snowflake/use_wh_new.png" alt></p><p>&emsp;&emsp;运行以下查询以查看数据示例：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> trips limit <span class="number">20</span>;</span><br></pre></td></tr></table></figure></p><p><img src="/Zero-to-Snowflake/select_top_20.png" alt></p><p>&emsp;&emsp;现在，让我们看一下花旗自行车使用情况。在工作表中运行下面的查询。对于每小时，它显示行程数、平均行程持续时间和平均行程距离。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> date_trunc(<span class="string">&#x27;hour&#x27;</span>, starttime) <span class="keyword">as</span> &quot;date&quot;,</span><br><span class="line"><span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> &quot;num trips&quot;,</span><br><span class="line"><span class="built_in">avg</span>(tripduration)<span class="operator">/</span><span class="number">60</span> <span class="keyword">as</span> &quot;avg duration (mins)&quot;,</span><br><span class="line"><span class="built_in">avg</span>(haversine(start_station_latitude, start_station_longitude, end_station_latitude, end_station_longitude)) <span class="keyword">as</span> &quot;avg distance (km)&quot;</span><br><span class="line"><span class="keyword">from</span> trips</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="number">1</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><img src="/Zero-to-Snowflake/avg_usage.png" alt></p><h2 id="使用结果缓存"><a href="#使用结果缓存" class="headerlink" title="使用结果缓存"></a>使用结果缓存</h2><p>&emsp;&emsp;Snowflake 有一个结果缓存，用于保存过去 24 小时内执行的每个查询的结果。这些查询在仓库中可用，因此，如果基础数据未更改，则返回给一个用户的查询结果可供系统上执行相同查询的任何其他用户使用。这些重复查询不仅返回速度极快，而且不使用计算积分。<br>&emsp;&emsp;让我们通过再次运行完全相同的查询来查看结果缓存的运行情况。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> date_trunc(<span class="string">&#x27;hour&#x27;</span>, starttime) <span class="keyword">as</span> &quot;date&quot;,</span><br><span class="line"><span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> &quot;num trips&quot;,</span><br><span class="line"><span class="built_in">avg</span>(tripduration)<span class="operator">/</span><span class="number">60</span> <span class="keyword">as</span> &quot;avg duration (mins)&quot;,</span><br><span class="line"><span class="built_in">avg</span>(haversine(start_station_latitude, start_station_longitude, end_station_latitude, end_station_longitude)) <span class="keyword">as</span> &quot;avg distance (km)&quot;</span><br><span class="line"><span class="keyword">from</span> trips</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="number">1</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><img src="/Zero-to-Snowflake/huanjun.png" alt></p><h2 id="执行另一个查询"><a href="#执行另一个查询" class="headerlink" title="执行另一个查询"></a>执行另一个查询</h2><p>&emsp;&emsp;接下来，让我们运行以下查询，看看哪些月份最忙：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">monthname(starttime) <span class="keyword">as</span> &quot;month&quot;,</span><br><span class="line"><span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> &quot;num trips&quot;</span><br><span class="line"><span class="keyword">from</span> trips</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="number">1</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="number">2</span> <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><p><img src="/Zero-to-Snowflake/another_sql.png" alt></p><h2 id="克隆表"><a href="#克隆表" class="headerlink" title="克隆表"></a>克隆表</h2><p>&emsp;&emsp;Snowflake 允许您在几秒钟内创建表、架构和数据库的克隆，也称为“零拷贝克隆”。创建克隆时，Snowflake 会拍摄源对象中存在的数据的快照，并将其提供给克隆对象。克隆的对象是可写的，并且独立于克隆源。因此，对源对象或克隆对象所做的更改不包括在另一个对象中。<br>&emsp;&emsp;零拷贝克隆的一个常见用例是克隆生产环境，供开发和测试团队用于测试和实验，而不会对生产环境产生不利影响，也无需设置和管理两个单独的环境。  </p><blockquote><p>零拷贝克隆的一大好处是不会复制基础数据。只有元数据和指向基础数据的指针会更改。因此，克隆是“零拷贝”，克隆数据时存储要求不会翻倍。大多数数据仓库无法做到这一点，但对于 Snowflake 来说，这很容易！</p></blockquote><p>&emsp;&emsp;在工作表中运行以下命令以创建表<code>trips</code>的克隆表<code>trips_dev</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> trips_dev clone trips;</span><br></pre></td></tr></table></figure><p><img src="/Zero-to-Snowflake/clone_trips.png" alt></p><p>&emsp;&emsp;单击左窗格中的三个点 <strong>···</strong>，然后选择<strong>刷新</strong>。现在可以对此表执行任何想要的操作，包括更新或删除它，而不会影响该表或任何其他对象。</p><h1 id="使用半结构化数据，视图，和连接"><a href="#使用半结构化数据，视图，和连接" class="headerlink" title="使用半结构化数据，视图，和连接"></a>使用半结构化数据，视图，和连接</h1><blockquote><p>本部分需要加载其他数据，因此，在介绍加载半结构化数据的同时，对数据加载进行了回顾。</p></blockquote><p>&emsp;&emsp;回到实验室的例子，Citi Bike 分析团队希望确定天气如何影响骑行计数。为此，在本节中，我们将：</p><ul><li>以半结构化 JSON 格式加载天气数据，保存在公有 S3 存储桶中。</li><li>创建视图并使用 SQL 点表示法查询 JSON 数据。</li><li>运行一个查询，将 JSON 数据联接到以前加载<code>TRIPS</code>的数据。</li><li>分析天气和乘车次数数据以确定它们之间的关系。</li></ul><p>&emsp;&emsp;JSON数据由MeteoStat提供的天气信息组成，详细介绍了2016-07-05至2019-06-25期间纽约市的历史状况。它还在 AWS S3 上暂存，其中数据由 75k 行、36 个对象和 1.1MB 压缩组成。如果在文本编辑器中查看，GZ 文件中的原始 JSON 如下所示：</p><p><img src="/Zero-to-Snowflake/json_data.png" alt></p><blockquote><p>Snowflake 可以轻松加载和查询 JSON、Parquet 或 Avro 等半结构化数据，而无需转换。这是 Snowflake 的一个关键功能，因为如今生成的越来越多的与业务相关的数据是半结构化的，许多传统数据仓库无法轻松加载和查询此类数据。Snowflake让一切变得简单！</p></blockquote><h2 id="为数据创建新的数据库和表"><a href="#为数据创建新的数据库和表" class="headerlink" title="为数据创建新的数据库和表"></a>为数据创建新的数据库和表</h2><p>&emsp;&emsp;首先，在工作表中，让我们创建一个用于存储半结构化 JSON 数据的数据库<code>WEATHER</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> database weather;</span><br><span class="line">use role sysadmin;</span><br><span class="line">use warehouse compute_wh;</span><br><span class="line">use database weather;</span><br><span class="line">use schema public;</span><br></pre></td></tr></table></figure><blockquote><p>请记住，您需要单独执行每个命令。但是，您可以通过选中所有命令，然后单击右上角<code>▶</code>按钮（或使用键盘快捷键<code>Ctrl + Enter</code>）来按顺序执行它们。</p></blockquote><p>&emsp;&emsp;接下来，让我们创建一个用于加载 JSON 数据的表<code>json_weather_data</code>。在工作表中，执行以下 CREATE TABLE 命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> json_weather_data (v variant);</span><br></pre></td></tr></table></figure><p><img src="/Zero-to-Snowflake/weateher_data.png" alt></p><blockquote><p>VARIANT 数据类型允许 Snowflake 读取半结构化数据，而无需预定义架构。</p></blockquote><h2 id="创建另一个外部stage"><a href="#创建另一个外部stage" class="headerlink" title="创建另一个外部stage"></a>创建另一个外部stage</h2><p>&emsp;&emsp;在工作表中，使用以下命令创建一个stage，该stage指向 AWS S3 上存储半结构化 JSON 数据的存储桶：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> stage nyc_weather</span><br><span class="line">url <span class="operator">=</span> <span class="string">&#x27;s3://snowflake-workshop-lab/zero-weather-nyc&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="/Zero-to-Snowflake/another_stage.png" alt></p><p>&emsp;&emsp;执行以下 LIST 命令以显示文件列表<code>nyc_weather</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list <span class="variable">@nyc_weather</span>;</span><br></pre></td></tr></table></figure><p><img src="/Zero-to-Snowflake/list_weather.png" alt></p><p>&emsp;&emsp;在结果窗格中，您应看到来自 S3 的文件列表<code>.gz</code></p><h2 id="加载并验证半结构化数据"><a href="#加载并验证半结构化数据" class="headerlink" title="加载并验证半结构化数据"></a>加载并验证半结构化数据</h2><p>&emsp;&emsp;在本节中，我们将使用仓库将数据从 S3 存储桶加载到我们之前创建的表中<code>JSON_WEATHER_DATA</code></p><p>&emsp;&emsp;在工作表中，执行下面的 COPY 命令以加载数据:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">copy</span> <span class="keyword">into</span> json_weather_data</span><br><span class="line"><span class="keyword">from</span> <span class="variable">@nyc_weather</span> </span><br><span class="line">    file_format <span class="operator">=</span> (type <span class="operator">=</span> json strip_outer_array <span class="operator">=</span> <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><blockquote><p>请注意，您可以在命令中内联指定对象。在上一节中，我们以 CSV 格式加载结构化数据，我们必须定义一种文件格式来支持 CSV 结构。由于此处的 JSON 数据格式正确，因此我们能够简单地指定 JSON 类型并使用所有默认设置</p></blockquote><p><img src="/Zero-to-Snowflake/copy_json_data.png" alt></p><p>&emsp;&emsp;现在，让我们看一下加载的数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> json_weather_data limit <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;单击任意一行在右侧面板中显示格式化的 JSON：</p><p><img src="/Zero-to-Snowflake/select_json_data.png" alt></p><h2 id="创建视图并查询半结构化数据"><a href="#创建视图并查询半结构化数据" class="headerlink" title="创建视图并查询半结构化数据"></a>创建视图并查询半结构化数据</h2><p>&emsp;&emsp;接下来，让我们看看 Snowflake 如何允许我们创建视图并直接使用 SQL 查询 JSON 数据。</p><blockquote><p>视图允许像访问表一样访问查询结果。视图可以帮助以更清晰的方式向最终用户呈现数据，限制最终用户可以在源表中查看的内容，并编写更多的模块化 SQL。Snowflake 还支持实例化视图，其中存储查询结果就像存储结果一样。这允许更快的访问，但需要存储空间。如果您使用的是 Snowflake Enterprise Edition（或更高版本），则可以创建和查询实例化视图。</p></blockquote><p>&emsp;&emsp;运行以下命令以创建半结构化 JSON 天气数据的列式视图，以便分析师更容易理解和查询。的值对应于 Newark Airport，这是整个期间有天气状况的最近车站。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> <span class="keyword">create</span> a <span class="keyword">view</span> that will put structure onto the semi<span class="operator">-</span>structured data</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> json_weather_data_view <span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">    v:obsTime::<span class="type">timestamp</span> <span class="keyword">as</span> observation_time,</span><br><span class="line">    v:station::string <span class="keyword">as</span> station_id,</span><br><span class="line">    v:name::string <span class="keyword">as</span> city_name,</span><br><span class="line">    v:country::string <span class="keyword">as</span> country,</span><br><span class="line">    v:latitude::<span class="type">float</span> <span class="keyword">as</span> city_lat,</span><br><span class="line">    v:longitude::<span class="type">float</span> <span class="keyword">as</span> city_lon,</span><br><span class="line">    v:weatherCondition::string <span class="keyword">as</span> weather_conditions,</span><br><span class="line">    v:coco::<span class="type">int</span> <span class="keyword">as</span> weather_conditions_code,</span><br><span class="line">    v:temp::<span class="type">float</span> <span class="keyword">as</span> temp,</span><br><span class="line">    v:prcp::<span class="type">float</span> <span class="keyword">as</span> rain,</span><br><span class="line">    v:tsun::<span class="type">float</span> <span class="keyword">as</span> tsun,</span><br><span class="line">    v:wdir::<span class="type">float</span> <span class="keyword">as</span> wind_dir,</span><br><span class="line">    v:wspd::<span class="type">float</span> <span class="keyword">as</span> wind_speed,</span><br><span class="line">    v:dwpt::<span class="type">float</span> <span class="keyword">as</span> dew_point,</span><br><span class="line">    v:rhum::<span class="type">float</span> <span class="keyword">as</span> relative_humidity,</span><br><span class="line">    v:pres::<span class="type">float</span> <span class="keyword">as</span> pressure</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">    json_weather_data</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    station_id <span class="operator">=</span> <span class="string">&#x27;72502&#x27;</span>;</span><br></pre></td></tr></table></figure><blockquote><p>此命令中使用 SQL 点表示法来提取 JSON 对象层次结构中较低级别的值。这使我们能够将每个字段视为关系表中的一列<code>v:temp</code></p></blockquote><p><img src="/Zero-to-Snowflake/create_view.png" alt></p><p>&emsp;&emsp;使用以下查询验证视图：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> json_weather_data_view</span><br><span class="line"><span class="keyword">where</span> date_trunc(<span class="string">&#x27;month&#x27;</span>,observation_time) <span class="operator">=</span> <span class="string">&#x27;2018-01-01&#x27;</span></span><br><span class="line">limit <span class="number">20</span>;</span><br></pre></td></tr></table></figure><p><img src="/Zero-to-Snowflake/select_view.png" alt></p><h2 id="使用联接操作与数据集相关联"><a href="#使用联接操作与数据集相关联" class="headerlink" title="使用联接操作与数据集相关联"></a>使用联接操作与数据集相关联</h2><p>&emsp;&emsp;现在，我们将把JSON天气数据加入到我们的数据中，以回答我们最初的问题，即天气如何影响乘车次数。</p><blockquote><p>因为我们仍在工作表中，所以数据库仍在使用中。因此，您必须通过提供表的数据库和架构名称来完全限定对表的引用。<code>WEATHER``TRIPS</code></p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> weather_conditions <span class="keyword">as</span> conditions</span><br><span class="line">,<span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> num_trips</span><br><span class="line"><span class="keyword">from</span> citibike.public.trips</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> json_weather_data_view</span><br><span class="line"><span class="keyword">on</span> date_trunc(<span class="string">&#x27;hour&#x27;</span>, observation_time) <span class="operator">=</span> date_trunc(<span class="string">&#x27;hour&#x27;</span>, starttime)</span><br><span class="line"><span class="keyword">where</span> conditions <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="number">1</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="number">2</span> <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><p><img src="/Zero-to-Snowflake/join.png" alt></p><p>&emsp;&emsp;最初的目标是通过分析乘客数量和天气数据来确定骑自行车的次数与天气之间是否存在任何相关性。根据上面的结果，我们有一个明确的答案。可以想象，天气好的时候，出行次数要多得多！</p><h1 id="使用Time-Travel"><a href="#使用Time-Travel" class="headerlink" title="使用Time Travel"></a>使用Time Travel</h1><p>&emsp;&emsp;Snowflake 强大的Time Travel功能可以在一段时间内的任何时间点访问历史数据以及存储数据的对象。默认窗口为 24 小时，如果您使用的是 Snowflake 企业版，则最多可以增加到 90 天。大多数数据仓库无法提供此功能，但是Snowflake 使它变得简单！</p><p>&emsp;&emsp;还包括：</p><ul><li>还原可能已删除的数据相关对象，例如表、架构和数据库。</li><li>复制和备份过去关键点的数据。</li><li>分析指定时间段内的数据使用情况和操作情况。</li></ul><h2 id="删除和取消删除表"><a href="#删除和取消删除表" class="headerlink" title="删除和取消删除表"></a>删除和取消删除表</h2><p>&emsp;&emsp;首先，让我们看看如何恢复被意外或有意删除的数据对象。</p><p>&emsp;&emsp;在工作表中，运行以下 DROP 命令删除该表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> json_weather_data;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;对表运行查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> json_weather_data limit <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在底部的结果窗格中，应会看到错误，因为基础表已被删除：</p><p><img src="/Zero-to-Snowflake/not_exist.png" alt></p><p>&emsp;&emsp;现在，还原表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">undrop <span class="keyword">table</span> json_weather_data;</span><br></pre></td></tr></table></figure><p><img src="/Zero-to-Snowflake/undrop.png" alt></p><p>&emsp;&emsp;应还原json_weather_data表。通过运行以下查询进行验证：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--verify table is undropped</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> json_weather_data limit <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><img src="/Zero-to-Snowflake/undrop_select.png" alt></p><h2 id="回滚表"><a href="#回滚表" class="headerlink" title="回滚表"></a>回滚表</h2><p>&emsp;&emsp;让我们将数据库中的表回滚到以前的状态，以修复一个无意的 DML 错误，该错误将表中的所有站点名称替换为单词<strong>“oops”</strong></p><p>&emsp;&emsp;首先，运行以下 SQL 语句将工作表切换到正确的上下文：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">use role sysadmin;</span><br><span class="line"></span><br><span class="line">use warehouse compute_wh;</span><br><span class="line"></span><br><span class="line">use database citibike;</span><br><span class="line"></span><br><span class="line">use schema public;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;运行以下命令，将表中的所有start_station_name更新为单词<strong>“oops”</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> trips <span class="keyword">set</span> start_station_name <span class="operator">=</span> <span class="string">&#x27;oops&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="/Zero-to-Snowflake/update_table.png" alt></p><p>&emsp;&emsp;现在，运行一个查询，该查询按乘车次数返回前 20 个站点。请注意，电台名称结果仅包含一行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">start_station_name <span class="keyword">as</span> &quot;station&quot;,</span><br><span class="line"><span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> &quot;rides&quot;</span><br><span class="line"><span class="keyword">from</span> trips</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="number">2</span> <span class="keyword">desc</span></span><br><span class="line">limit <span class="number">20</span>;</span><br></pre></td></tr></table></figure><p><img src="/Zero-to-Snowflake/oops.png" alt></p><p>&emsp;&emsp;通常情况下，希望我们有一个备份。</p><p>&emsp;&emsp;在Snowflake 中，我们可以简单地运行一个命令来查找最后一个 UPDATE 命令的查询 ID，并将其存储在名为<code>$QUERY_ID</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> query_id <span class="operator">=</span></span><br><span class="line">(<span class="keyword">select</span> query_id <span class="keyword">from</span> <span class="keyword">table</span>(information_schema.query_history_by_session (result_limit<span class="operator">=</span><span class="operator">&gt;</span><span class="number">5</span>))</span><br><span class="line"><span class="keyword">where</span> query_text <span class="keyword">like</span> <span class="string">&#x27;update%&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> start_time <span class="keyword">desc</span> limit <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p><img src="/Zero-to-Snowflake/set_query_id.png" alt></p><p>&emsp;&emsp;使用<strong>Time Interval</strong>重新创建表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">table</span> trips <span class="keyword">as</span></span><br><span class="line">(<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> trips before (statement <span class="operator">=</span><span class="operator">&gt;</span> $query_id));</span><br></pre></td></tr></table></figure><p><img src="/Zero-to-Snowflake/time_int.png" alt></p><p>&emsp;&emsp;再次运行上一个查询，以验证是否已还原：</p><p><img src="/Zero-to-Snowflake/query_again.png" alt></p><h1 id="角色、帐户管理员和帐户使用情况"><a href="#角色、帐户管理员和帐户使用情况" class="headerlink" title="角色、帐户管理员和帐户使用情况"></a>角色、帐户管理员和帐户使用情况</h1><p>&emsp;&emsp;在本节中，我们将探讨 Snowflake 访问控制安全模型的各个方面，例如创建角色并授予其特定权限。我们还将探讨 ACCOUNTADMIN（帐户管理员）角色的其他用法，该角色在前面的实验中已简要介绍。</p><p>&emsp;&emsp;假设一个初级 DBA 加入了 Citi Bike，我们希望为他们创建一个新角色，其权限低于系统定义的默认角色 SYSADMIN。</p><blockquote><p>基于角色的访问控制Snowflake 提供了非常强大且精细的访问控制，它决定了用户可以访问的对象和功能，以及他们拥有的访问级别。有关更多详细信息，请查看 <a href="https://docs.snowflake.com/user-guide/security-access-control-overview"><strong>Snowflake 文档</strong></a>。</p></blockquote><h2 id="创建新角色并添加用户"><a href="#创建新角色并添加用户" class="headerlink" title="创建新角色并添加用户"></a>创建新角色并添加用户</h2><p>&emsp;&emsp;在工作表中，切换到 <code>ACCOUNTADMIN</code> 角色以创建新角色。<code>ACCOUNTADMIN</code> 封装了<code>SYSADMIN</code> 和 <code>SECURITYADMIN</code> 系统定义的角色。它是账户中的顶级角色，应仅授予有限数量的用户。</p><p>&emsp;&emsp;运行以下命令</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use role accountadmin;</span><br></pre></td></tr></table></figure><p><img src="/Zero-to-Snowflake/use_role_acc.png" alt></p><p>&emsp;&emsp;请注意，在工作表的右上角，已更改为 <code>ACCOUNTADMIN</code>：</p><p><img src="/Zero-to-Snowflake/acc_adm.png" alt></p><p>&emsp;&emsp;在将角色用于访问控制之前，必须至少为其分配一个用户。因此，让我们创建一个名为 Snowflake 的新角色，并将其分配给您的 Snowflake 用户。</p><p>&emsp;&emsp;使用以下命令创建角色并将其分配给您。在运行 GRANT ROLE 命令之前，请将<code>YOUR_USERNAME_GOES_HERE</code>替换为您的用户名：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> role junior_dba;</span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> users;</span><br><span class="line"></span><br><span class="line"><span class="keyword">grant</span> role junior_dba <span class="keyword">to</span> <span class="keyword">user</span> YOUR_USERNAME_GOES_HERE;  <span class="comment">--YOUR_USERNAME_GOES_HERE这里为登录snowflake的用户名</span></span><br></pre></td></tr></table></figure><p><img src="/Zero-to-Snowflake/grant_role.png" alt></p><blockquote><p>如果尝试在 SYSADMIN 等角色中执行此操作，则会因权限不足而失败。默认情况下（和设计），SYSADMIN 角色无法创建新角色或用户。</p></blockquote><p>&emsp;&emsp;将工作表上下文更改为新角色<code>JUNIOR_DBA</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use role junior_dba;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;请注意，在工作表的右上角已更改为<code>JUNIOR_DBA</code><br><img src="/Zero-to-Snowflake/junior_dba.png" alt></p><p>&emsp;&emsp;此外，由于新创建的角色对任何仓库都没有使用权限，因此未选择仓库。让我们通过切换回 <code>ADMIN</code> 角色并授予仓库使用权限：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use role accountadmin;</span><br><span class="line"></span><br><span class="line"><span class="keyword">grant</span> usage <span class="keyword">on</span> warehouse compute_wh <span class="keyword">to</span> role junior_dba;</span><br></pre></td></tr></table></figure><p><img src="/Zero-to-Snowflake/grant_usage_jud.png" alt></p><p>&emsp;&emsp;切换回角色。您现在应该可以使用<code>JUNIOR_DBA</code>和<code>COMPUTE_WH</code>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use role junior_dba;</span><br><span class="line"></span><br><span class="line">use warehouse compute_wh;</span><br></pre></td></tr></table></figure><p><img src="/Zero-to-Snowflake/use_war_com.png" alt></p><p>&emsp;&emsp;最后，您可以注意到，在左侧的数据库对象面板中，不再显示数据库。这是因为该角色没有访问它们的权限。</p><p><img src="/Zero-to-Snowflake/no_db.png" alt></p><p>&emsp;&emsp;切换回 ACCOUNTADMIN 角色，并授予查看和使用 and 数据库所需的 USAGE 权限：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use role accountadmin;</span><br><span class="line"></span><br><span class="line"><span class="keyword">grant</span> usage <span class="keyword">on</span> database citibike <span class="keyword">to</span> role junior_dba;</span><br><span class="line"></span><br><span class="line"><span class="keyword">grant</span> usage <span class="keyword">on</span> database weather <span class="keyword">to</span> role junior_dba;</span><br></pre></td></tr></table></figure><p><img src="/Zero-to-Snowflake/uggu.png" alt></p><p>&emsp;&emsp;数据库现在显示在左侧的数据库对象浏览器面板中。如果它们未出现，请尝试单击面板中的<strong>···</strong>，然后单击<strong>Refresh</strong></p><h2 id="查看帐户管理员-UI"><a href="#查看帐户管理员-UI" class="headerlink" title="查看帐户管理员 UI"></a>查看帐户管理员 UI</h2><p>&emsp;&emsp;让我们将访问控制角色改回，以查看只有此角色才能访问的 UI 的其他区域。但是，若要执行此任务，请使用 UI 而不是工作表。</p><p>&emsp;&emsp;首先，点击<strong>主页</strong>工作表左下角的图标。然后单击您的姓名以显示用户首选项菜单。在菜单中，转到<strong>Switch Role</strong>，然后选择<strong>ACCOUNTADMIN</strong>。</p><p><img src="/Zero-to-Snowflake/swich_acc.png" alt></p><blockquote><p>为什么我们使用用户首选项菜单而不是工作表来更改角色？UI 会话和每个工作UI 会话和每个工作表都有它们自己独立的角色。UI 会话角色控制您在用户界面中可以看到和访问的元素，而工作表角色仅控制您可以在该角色内访问的对象和操作。</p></blockquote><p><img src="/Zero-to-Snowflake/CM.png" alt></p><p><img src="/Zero-to-Snowflake/Consumption.png" alt></p><h1 id="Sharing-Data-Securely-amp-the-Data-Marketplace"><a href="#Sharing-Data-Securely-amp-the-Data-Marketplace" class="headerlink" title="Sharing Data Securely &amp; the Data Marketplace"></a>Sharing Data Securely &amp; the Data Marketplace</h1><p>&emsp;&emsp;略  </p><blockquote><p><a href="https://quickstarts.snowflake.com/guide/getting_started_with_snowflake/#9"><strong>如有兴趣可以点此查看</strong></a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Snowflake </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Snowflake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Snowflake注册</title>
      <link href="/Snowflake-register/"/>
      <url>/Snowflake-register/</url>
      
        <content type="html"><![CDATA[<h1 id="Snowflake注册"><a href="#Snowflake注册" class="headerlink" title="Snowflake注册"></a>Snowflake注册</h1><h2 id="1、Snoflake注册"><a href="#1、Snoflake注册" class="headerlink" title="1、Snoflake注册"></a>1、Snoflake注册</h2><p>&emsp;&emsp;Snowflake为开发者提供了30天400美元的免费的额度，用完为止。注册地址：<a href="https://signup.snowflake.com/">https://signup.snowflake.com/</a></p><h2 id="2、注册步骤"><a href="#2、注册步骤" class="headerlink" title="2、注册步骤"></a>2、注册步骤</h2><p><img src="/Snowflake-register/form.png" alt></p><ul><li>打开连接 <a href="https://signup.snowflake.com/">https://signup.snowflake.com/</a> ，从上至下依次填写表单 姓名、邮箱、公司名、职位、国家，点击<strong>CONTINUE</strong>（最好使用outlook或google邮箱注册，国内邮箱可能会出现失败的情况）；<br><img src="/Snowflake-register/version2.png" alt></li><li>选择Snowflake edition和Cloud provider，这里选择了<strong>Enterprise</strong>和<strong>Amazon Web Services</strong>，区域选择<strong>Tokyo</strong>（离国内进），点击<strong>GET STARTED</strong>；<br><img src="/Snowflake-register/diaocha.png" alt></li><li>调查问卷，选择<strong>跳过</strong>；<br><img src="/Snowflake-register/email_v.png" alt></li><li>注册完成，邮箱验证激活；<br><img src="/Snowflake-register/email_receive.png" alt></li><li>登录自己刚刚注册填写的邮箱，查看是否收到了一封标题为<strong>Activate your Snowflake account</strong>的邮件，如果没收到，看一下垃圾邮件里，点击<strong>CLICK TO ACTIVATE</strong>，记住下面的这个链接 <strong><a href="https://rwmpdkz-lr40722.snowflakecomputing.com">https://rwmpdkz-lr40722.snowflakecomputing.com</a></strong>，以后可以通过这个链接来登录Snowflake；<br><img src="/Snowflake-register/register.png" alt></li><li>输入需要注册的用户名以及密码，点击<strong>Get started</strong>；<br><img src="/Snowflake-register/finish.png" alt></li><li>完成注册~！</li></ul><h1 id="DBever连接Snowflake"><a href="#DBever连接Snowflake" class="headerlink" title="DBever连接Snowflake"></a>DBever连接Snowflake</h1><ul><li><a href="https://repo1.maven.org/maven2/net/snowflake/snowflake-jdbc/3.14.4/">https://repo1.maven.org/maven2/net/snowflake/snowflake-jdbc/3.14.4/</a> 下载Snowflake驱动<strong>snowflake-jdbc-3.14.4.jar</strong> ；<br><img src="/Snowflake-register/dbever.png" alt></li><li>打开DBever，点击左上角<strong>新建数据库连接</strong>，搜索框里搜索<strong>Snowflake</strong>，点击<strong>下一步</strong>；<br><img src="/Snowflake-register/connected.png" alt></li><li>Host填写刚刚注册的邮件里的链接 <strong>（在上边让你记住的那个）</strong>，Database、Warehouse<strong>按需填写</strong>，用户名、密码填写<strong>注册的用户名以及密码</strong>，点击<strong>编辑驱动设置</strong>；<br><img src="/Snowflake-register/add_driven.png" alt></li><li>点击<strong>库</strong>，把自带的<strong>全选</strong>，<strong>删除</strong>掉；<br><img src="/Snowflake-register/add_driven2.png" alt></li><li>点击<strong>添加文件</strong>，找到刚刚下载的<strong>snowflake-jdbc-3.14.4.jar</strong>添加进来，点击确定；<br><img src="/Snowflake-register/fini.png" alt></li><li>点击<strong>测试连接</strong>，出现<strong>已连接</strong>，表示成功连接到Snowflake，点击<strong>确定</strong>，点击<strong>完成</strong>；<br><img src="/Snowflake-register/completed.png" alt></li><li>双击打开<strong>左侧的数据库连接</strong>，即可使用DBever，管理Snowflake。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Snowflake </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Snowflake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Snowflake❄</title>
      <link href="/Snowflake/"/>
      <url>/Snowflake/</url>
      
        <content type="html"><![CDATA[<h1 id="Snowflake：一个革命性的云数据平台"><a href="#Snowflake：一个革命性的云数据平台" class="headerlink" title="Snowflake：一个革命性的云数据平台"></a>Snowflake：一个革命性的云数据平台</h1><h2 id="1-什么是Snowflake？"><a href="#1-什么是Snowflake？" class="headerlink" title="1. 什么是Snowflake？"></a>1. 什么是Snowflake？</h2><p>&emsp;&emsp;Snowflake是一种云数据仓库，它提供了一个全面的、基于SQL的数据分析解决方案。Snowflake以其独特的架构和优秀的性能，赢得了许多企业的青睐。它的设计理念是将计算和存储分离，使得用户可以独立地调整这两个方面，以满足自身的需求。</p><h2 id="2-Snowflake的特点"><a href="#2-Snowflake的特点" class="headerlink" title="2. Snowflake的特点"></a>2. Snowflake的特点</h2><h3 id="2-1-传统数仓-计算与存储耦合"><a href="#2-1-传统数仓-计算与存储耦合" class="headerlink" title="2.1 传统数仓 - 计算与存储耦合"></a>2.1 传统数仓 - 计算与存储耦合</h3><p float="center">  <img src="/Snowflake/shared-nothing.png" width="500"></p><p>&emsp;&emsp;传统数据仓库通常采用的是计算和存储耦合的架构(<strong>Shared-nothing Architecture</strong>)。在这种架构中，每个节点都有自己的计算资源和存储空间，数据被横向分布在各个节点上。计算过程中，每个节点只需处理其自身存储的数据。<br>&emsp;&emsp;这种架构的优点在于理论上速度很快，因为它减少了数据在各节点间的传输时间，并且在数据处理过程中不会出现资源争抢的情况。然而，这种架构也有一些明显的缺点，包括：  </p><ul><li>数据分布不均匀，因为数据需要预先分配到各个节点，而每个节点只处理其自身的数据；  </li><li>节点的增加或减少操作相当复杂，因为大量数据需要重新分配；  </li><li>无法单独增加计算资源或存储资源，因为计算和存储是耦合的。这意味着，当增加存储资源时，也会增加计算资源，但这些计算资源可能并不需要。  </li></ul><h3 id="2-2-Snowflake-计算与存储分离"><a href="#2-2-Snowflake-计算与存储分离" class="headerlink" title="2.2 Snowflake - 计算与存储分离"></a>2.2 Snowflake - 计算与存储分离</h3><p float="center">  <img src="/Snowflake/architecture.png" width="1000"></p><p>&emsp;&emsp;为了应对传统数据仓库的挑战，Snowflake引入了一种新的架构，即计算和存储的分离架构(<strong>Shared-data Architecture</strong>)。在这一架构中，存储层只负责数据的存储，而计算层则专注于数据的计算。在每次计算过程中，计算节点会从存储层均匀地获取数据，然后在节点内部完成计算。<br>&emsp;&emsp;这种架构允许用户自由地增加或减少计算资源和存储空间。计算层是Shared-nothing的Virtual Warehouse，由EC2的Cluster组成，每个EC2为一个Worker Node，包含本地的Local Disk作为Table Data Cache。如果Query很复杂，可以选择增加每个Virtual Warehouse的计算节点的数量；如果并发性很重要，那就可以选择增加Virtual Warehouse的数量。当使用完毕后，可以关闭所有的Virtual Warehouse，这样只需要为存储空间付费，而不需要为计算资源付费。<br>&emsp;&emsp;存储层是Amazon S3(目前也支持Microsoft Azure 和Google Cloud Platform)，它可以被视为具有无限容量、数据不会丢失且成本超低的存储解决方案。</p><blockquote><p>微软对Snowflake的支持，首先，微软的云服务业务模型主要依赖规模来吸引消费。因此，尽管从某种程度上来说，支持Snowflake可能会冲击微软自家的数据服务，但是，如果Snowflake的用户选择将数据存储在Azure上，那么这对微软来说就是有利的。这种策略的核心就是，无论客户选择使用什么样的解决方案，只要他们的数据在微软的掌控之下，微软就会提供支持。 其次，未来的趋势是多云，也就是说，企业会选择将数据和服务分布在多个云平台上，以降低技术和商业风险。在这种情况下，易于迁移就变得尤为重要。如果微软只是防守自家的领地，那么客户就无法从AWS轻松转移到Azure。相反，如果微软提供了在Azure上运行Snowflake的解决方案，那么就为AWS的客户提供了一个转换的机会。这个观点可以通过观察Snowflake最近一轮由Salesforce领投的融资情况得到验证，这进一步证明了数据共享战略的重要性。 最后，从战略角度来看，微软不仅要培养良好的合作伙伴，也需要培养强大的竞争对手。比如，Azure Databricks就是一个很好的例子。尽管许多人误以为Databricks是微软的产品，但实际上，Azure Databricks已经成为了Azure的一线服务。云计算的目标是让客户得到最大的便利，如果有优秀的技术，那么平台应当吸引并支持这些技术的使用。</p></blockquote><h3 id="2-3-性能优化"><a href="#2-3-性能优化" class="headerlink" title="2.3 性能优化"></a>2.3 性能优化</h3><p>&emsp;&emsp;尽管Snowflake解决了传统数据仓库的一些关键问题，但是传统数据仓库的优势——性能，却是Snowflake的短板。为了优化性能，Snowflake进行了以下几项工作：  </p><div style="display: flex; justify-content: space-around;">  <figure>    <img src="/Snowflake/localcaching.png" width="400">    <figcaption style="text-align: center;">Local Caching</figcaption>  </figure></div><ul><li><strong>Local Caching</strong>： 每个节点都会保存一些常用的数据在本地的硬盘上，这些数据相当于cache，查询时会按照<a href="https://baike.baidu.com/item/LRU"><strong>LRU</strong></a>的方法逐渐替换掉local cache中的data。在分配任务时，服务层会采用一次性Hash的方法给每个节点分配任务，尽可能地增加cache hit rate，从而减少计算层和存储层之间的传输，从而加快处理速度。</li></ul><div style="display: flex; justify-content: space-around;">  <figure>    <img src="/Snowflake/filestealing.png" width="400">    <figcaption style="text-align: center;">File Stealing1</figcaption>  </figure>  <figure>    <img src="/Snowflake/filestealing2.png" width="400">    <figcaption style="text-align: center;">File Stealing2</figcaption>  </figure></div><ul><li><strong>File Stealing</strong>： 假设存在两个计算节点，每个节点都被赋予了三个文件的处理任务。节点1迅速完成了其三个文件的处理，而节点2还未开始处理任何文件。在这种情况下，如果得到节点2的许可，节点1可以将节点2的一个文件的所有权转移到自己身上。这样，处理速度较快的节点1就能处理更多的文件，而处理速度较慢的节点2的负载则相应减轻，从而达到整体的加速效果。</li></ul><div style="display: flex; justify-content: space-around;">  <figure>    <img src="/Snowflake/storage.png" width="500">    <figcaption style="text-align: center;">Storage1</figcaption>  </figure>  <figure>    <img src="/Snowflake/storage2.png" width="400">    <figcaption style="text-align: center;">Storage2</figcaption>  </figure></div><ul><li><strong>Storage</strong>： 第三个优化策略关注于存储层的优化。所有的表格文件在存储时会被水平地切分成n个部分，每一部分采用列式存储的方式，并存储在Amazon S3中。此外，每一个文件块都会有一个header信息，用于记录每一列的存储位置（offset）。这些文件块的信息都会被记录在服务层。当用户发出一个查询请求时，服务层可以根据该查询请求精确地找出所需数据在存储层的位置，从而避免了无用的内容读取，实现了加速效果。</li></ul><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>&emsp;&emsp;Snowflake是一个强大的云数据平台，它提供了一种简单，高效，灵活的方式来处理和分析数据。无论你是一个小型团队，还是一个大型企业，Snowflake都能够满足你的需求。  </p><p>未完。。。</p><p><strong>参考资料：</strong><br><a href="https://pages.cs.wisc.edu/~remzi/Classes/739/Fall2018/Papers/p215-dageville-snowflake.pdf">[1]Dageville, Benoît, Cruanes T , Zukowski M ,et al.The Snowflake Elastic Data Warehouse.[C]//ACM.ACM, 2016.DOI:10.1145/2882903.2903741.</a><br><a href="https://www.bilibili.com/video/BV1oK41137AX">https://www.bilibili.com/video/BV1oK41137AX</a><br><a href="https://zhuanlan.zhihu.com/p/54439354">https://zhuanlan.zhihu.com/p/54439354</a><br><a href="https://zhuanlan.zhihu.com/p/594213354">https://zhuanlan.zhihu.com/p/594213354</a><br><a href="https://developer.aliyun.com/article/789944">https://developer.aliyun.com/article/789944</a><br><a href="https://zhuanlan.zhihu.com/p/366369705">https://zhuanlan.zhihu.com/p/366369705</a><br><a href="https://www-conf.slac.stanford.edu/xldb2016/talks/published/Tues_7_Marcin_Z_XLDB-2016-05-24-release.pdf">https://www-conf.slac.stanford.edu/xldb2016/talks/published/Tues_7_Marcin_Z_XLDB-2016-05-24-release.pdf</a>  </p>]]></content>
      
      
      <categories>
          
          <category> Snowflake </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Snowflake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/hello-world/"/>
      <url>/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><p><img src="/hello-world/23027a7c.png" alt></p><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post1&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/modify.css"/>
      <url>/css/modify.css</url>
      
        <content type="html"><![CDATA[#page-header {  background: transparent !important;}#page-header.post-bg,#page-header.not-home-page {  height: 280px !important;}#page-header #post-info {  bottom: 40px !important;}#page-header #page-site-info {  top: 140px !important;}@media screen and (max-width: 768px) {  #page-header.not-home-page {    height: 200px !important;  }  #page-header #post-info {    bottom: 10px !important;  }  #page-header #page-site-info {    top: 100px !important;  }}.top-img {  height: 250px;  margin: -50px -40px 50px;  border-top-left-radius: inherit;  border-top-right-radius: inherit;  background-position: center center;  background-size: cover;  -webkit-transition: all 0.3s;  -moz-transition: all 0.3s;  -o-transition: all 0.3s;  -ms-transition: all 0.3s;  transition: all 0.3s;}@media screen and (max-width: 768px) {  .top-img {    height: 230px;    margin: -36px -14px 36px;  }}[data-theme='dark'] .top-img {  filter: brightness(0.8);}#footer:before {  background-color: rgba(255,255,255,0.5);}[data-theme='dark'] #footer:before {  background-color: rgba(0,0,0,0.5);}#footer-wrap,#footer-wrap a {  color: #111;  -webkit-transition: unset;  -moz-transition: unset;  -o-transition: unset;  -ms-transition: unset;  transition: unset;}[data-theme='dark'] #footer-wrap,[data-theme='dark'] #footer-wrap a {  color: var(--light-grey);}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>友情链接</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/universe.css"/>
      <url>/css/universe.css</url>
      
        <content type="html"><![CDATA[/* 背景宇宙星光  */#universe{  display: block;  position: fixed;  margin: 0;  padding: 0;  border: 0;  outline: 0;  left: 0;  top: 0;  width: 100%;  height: 100%;  pointer-events: none;  /* 这个是调置顶的优先级的，-1在文章页下面，背景上面，个人推荐这种 */  z-index: -1;}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/universe.js"/>
      <url>/js/universe.js</url>
      
        <content type="html"><![CDATA[function dark() {window.requestAnimationFrame=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||window.msRequestAnimationFrame;var n,e,i,h,t=.05,s=document.getElementById("universe"),o=!0,a="180,184,240",r="226,225,142",d="226,225,224",c=[];function f(){n=window.innerWidth,e=window.innerHeight,i=.216*n,s.setAttribute("width",n),s.setAttribute("height",e)}function u(){h.clearRect(0,0,n,e);for(var t=c.length,i=0;i<t;i++){var s=c[i];s.move(),s.fadeIn(),s.fadeOut(),s.draw()}}function y(){this.reset=function(){this.giant=m(3),this.comet=!this.giant&&!o&&m(10),this.x=l(0,n-10),this.y=l(0,e),this.r=l(1.1,2.6),this.dx=l(t,6*t)+(this.comet+1-1)*t*l(50,120)+2*t,this.dy=-l(t,6*t)-(this.comet+1-1)*t*l(50,120),this.fadingOut=null,this.fadingIn=!0,this.opacity=0,this.opacityTresh=l(.2,1-.4*(this.comet+1-1)),this.do=l(5e-4,.002)+.001*(this.comet+1-1)},this.fadeIn=function(){this.fadingIn&&(this.fadingIn=!(this.opacity>this.opacityTresh),this.opacity+=this.do)},this.fadeOut=function(){this.fadingOut&&(this.fadingOut=!(this.opacity<0),this.opacity-=this.do/2,(this.x>n||this.y<0)&&(this.fadingOut=!1,this.reset()))},this.draw=function(){if(h.beginPath(),this.giant)h.fillStyle="rgba("+a+","+this.opacity+")",h.arc(this.x,this.y,2,0,2*Math.PI,!1);else if(this.comet){h.fillStyle="rgba("+d+","+this.opacity+")",h.arc(this.x,this.y,1.5,0,2*Math.PI,!1);for(var t=0;t<30;t++)h.fillStyle="rgba("+d+","+(this.opacity-this.opacity/20*t)+")",h.rect(this.x-this.dx/4*t,this.y-this.dy/4*t-2,2,2),h.fill()}else h.fillStyle="rgba("+r+","+this.opacity+")",h.rect(this.x,this.y,this.r,this.r);h.closePath(),h.fill()},this.move=function(){this.x+=this.dx,this.y+=this.dy,!1===this.fadingOut&&this.reset(),(this.x>n-n/4||this.y<0)&&(this.fadingOut=!0)},setTimeout(function(){o=!1},50)}function m(t){return Math.floor(1e3*Math.random())+1<10*t}function l(t,i){return Math.random()*(i-t)+t}f(),window.addEventListener("resize",f,!1),function(){h=s.getContext("2d");for(var t=0;t<i;t++)c[t]=new y,c[t].reset();u()}(),function t(){document.getElementsByTagName('html')[0].getAttribute('data-theme')=='dark'&&u(),window.requestAnimationFrame(t)}()};dark()]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>电影</title>
      <link href="/movies/index.html"/>
      <url>/movies/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>音乐</title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
